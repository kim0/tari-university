<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Bulletproof Protocols - Tari Labs University</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A collection of learning resources for cryptocurrency">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
            }
          });
        </script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <img src="../../theme/images/tlu.png" class="tlu">

            <ol class="chapter"><li class="affix"><a href="../../preface/introduction.html">Introduction</a></li><li><a href="../../cryptography/cryptography.html"><strong aria-hidden="true">1.</strong> Cryptography</a></li><li><ol class="section"><li><a href="../../cryptography/crypto-1/sources/PITCHME.link.html"><strong aria-hidden="true">1.1.</strong> Elliptic Curves 101</a></li><li><a href="../../cryptography/digital_signatures/introduction.html"><strong aria-hidden="true">1.2.</strong> Introduction to Schnorr signatures</a></li><li><ol class="section"><li><a href="../../cryptography/digital_signatures/basics.html"><strong aria-hidden="true">1.2.1.</strong> Basics of Schnorr signatures</a></li><li><a href="../../cryptography/digital_signatures/schnorr_signatures.html"><strong aria-hidden="true">1.2.2.</strong> Signature Aggregation</a></li></ol></li><li><a href="../../cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html"><strong aria-hidden="true">1.3.</strong> Introduction to Scriptless Scripts</a></li><li><a href="../../cryptography/fraud-proofs-1/MainReport.html"><strong aria-hidden="true">1.4.</strong> Fraud Proofs</a></li><li><a href="../../cryptography/bulletproofs-and-mimblewimble/MainReport.html"><strong aria-hidden="true">1.5.</strong> Bulletproofs and Mimblewimble</a></li><li><a href="../../cryptography/bulletproofs-protocols/MainReport.html" class="active"><strong aria-hidden="true">1.6.</strong> The Bulletproof Protocols</a></li></ol></li><li><a href="../../consensus-mechanisms/consensus-mechanisms.html"><strong aria-hidden="true">2.</strong> Consensus Mechanisms</a></li><li><ol class="section"><li><a href="../../consensus-mechanisms/BFT-consensusmechanisms/sources/PITCHME.link.html"><strong aria-hidden="true">2.1.</strong> BFT Consensus Mechanisms</a></li><li><a href="../../consensus-mechanisms/BFT-consensus-mechanisms-applications/Introduction.html"><strong aria-hidden="true">2.2.</strong> Introduction to Applications of Byzantine Consensus Mechanisms</a></li><li><ol class="section"><li><a href="../../consensus-mechanisms/BFT-consensus-mechanisms-applications/Permissioned-Byzantine-Fault-Tolerant-Protocols.html"><strong aria-hidden="true">2.2.1.</strong> Permissioned Byzantine Fault Tolerant Protocols</a></li><li><a href="../../consensus-mechanisms/BFT-consensus-mechanisms-applications/Permissionless-Byzantine-Fault-Tolerant-Protocols(Part1).html"><strong aria-hidden="true">2.2.2.</strong> Permissionless Byzantine Fault Tolerant Protocols (Part 1)</a></li><li><a href="../../consensus-mechanisms/BFT-consensus-mechanisms-applications/Permissionless-Byzantine-Fault-Tolerant-Protocols(Part2).html"><strong aria-hidden="true">2.2.3.</strong> Permissionless Byzantine Fault Tolerant Protocols (Part 2)</a></li><li><a href="../../consensus-mechanisms/BFT-consensus-mechanisms-applications/Summary-of-Findings.html"><strong aria-hidden="true">2.2.4.</strong> Summary of Findings</a></li><li><a href="../../consensus-mechanisms/BFT-consensus-mechanisms-applications/References.html"><strong aria-hidden="true">2.2.5.</strong> References</a></li><li><a href="../../consensus-mechanisms/BFT-consensus-mechanisms-applications/Appendix.html"><strong aria-hidden="true">2.2.6.</strong> Appendix</a></li></ol></li></ol></li><li><a href="../../layer2scaling/layer2scaling.html"><strong aria-hidden="true">3.</strong> Layer 2 Scaling</a></li><li><ol class="section"><li><a href="../../layer2scaling/layer2scaling-landscape/layer2scaling-survey.html"><strong aria-hidden="true">3.1.</strong> Layer 2 Scaling Survey (part 1)</a></li><li><a href="../../layer2scaling/more-landscape/landscape-update.html"><strong aria-hidden="true">3.2.</strong> Layer 2 Scaling Survey (part 2)</a></li><li><a href="../../layer2scaling/executive-summary/sources/PITCHME.link.html"><strong aria-hidden="true">3.3.</strong> Layer 2 Scaling Survey Executive Summary</a></li></ol></li><li><a href="../../merged-mining/merged-mining.html"><strong aria-hidden="true">4.</strong> Merged Mining</a></li><li><ol class="section"><li><a href="../../merged-mining/merged-mining-scene/MergedMiningIntroduction.html"><strong aria-hidden="true">4.1.</strong> Merged Mining Introduction</a></li></ol></li><li><a href="../../digital-assets/digital-assets.html"><strong aria-hidden="true">5.</strong> Digital Assets</a></li><li><ol class="section"><li><a href="../../digital-assets/nft-landscape-1/sources/PITCHME.link.html"><strong aria-hidden="true">5.1.</strong> Non-fungible Tokens Survey</a></li><li><a href="../../digital-assets/confidential-assets/MainReport.html"><strong aria-hidden="true">5.2.</strong> Confidential Assets</a></li></ol></li><li><a href="../../protocols/protocols.html"><strong aria-hidden="true">6.</strong> Protocols</a></li><li><ol class="section"><li><a href="../../protocols/mimblewimble-1/sources/PITCHME.link.html"><strong aria-hidden="true">6.1.</strong> Mimblewimble</a></li><li><a href="../../protocols/grin-protocol-overview/MainReport.html"><strong aria-hidden="true">6.2.</strong> Mimblewimble-Grin Block Chain Protocol Overview</a></li><li><a href="../../protocols/grin-beam-comparison/MainReport.html"><strong aria-hidden="true">6.3.</strong> Grin vs. BEAM; a Comparison</a></li><li><a href="../../protocols/grin-design-choice-criticisms/MainReport.html"><strong aria-hidden="true">6.4.</strong> Grin Design Choice Criticisms - Truth or Fiction</a></li><li><a href="../../protocols/atomic-swaps/AtomicSwaps.html"><strong aria-hidden="true">6.5.</strong> Atomic Swaps</a></li><li><a href="../../protocols/lightning-network-for-dummies/sources/PITCHME.link.html"><strong aria-hidden="true">6.6.</strong> Lightning Network for Dummies</a></li><li><a href="../../protocols/merkle-trees-and-spv-1/sources/PITCHME.link.html"><strong aria-hidden="true">6.7.</strong> Introduction to SPV, Merkle Trees and Bloom Filters</a></li><li><a href="../../protocols/rgb-introduction/sources/PITCHME.link.html"><strong aria-hidden="true">6.8.</strong> The RGB Protocol - An Introduction</a></li></ol></li><li><a href="../../labs/introduction.html"><strong aria-hidden="true">7.</strong> Labs</a></li><li><ol class="section"><li><a href="../../labs/mermaid-demo.html"><strong aria-hidden="true">7.1.</strong> Mermaid Demonstration</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">
<svg width="23px" height="23px" viewBox="0 0 23 23 version="1.1" class="gem" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M0,6.12859037 L0,12.5315952 L9.50941704,23 L23,12.5722492 L23,6.12859037 L9.56098655,0 L0,6.12859037 Z M8.37488789,18.3349536 L2.3103139,11.6575342 L2.3103139,8.02916483 L8.37488789,9.56385329 L8.37488789,18.3349536 Z M10.6748879,19.2090146 L10.6748879,10.1533363 L19.4932735,12.3893062 L10.6748879,19.2090146 Z M20.7,7.57180734 L20.7,10.3464428 L4.17713004,6.15908087 L9.74663677,2.58152894 L20.7,7.57180734 Z" id="Shape" fill="#000000" fill-rule="nonzero"></path>
    </g>
</svg></h1> 

                        <div class="right-buttons">
                            <a href="../../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#the-bulletproof-protocols" id="the-bulletproof-protocols"><h1>The Bulletproof Protocols</h1></a>
<a class="header" href="#introduction" id="introduction"><h2>Introduction</h2></a>
<p>An overview of Bulletproofs have been given in <a href="../bulletproofs-and-mimblewimble/MainReport.html">Bulletproofs and Mimblewimble</a>, which has largely been based on the original work done by Bünz et al. [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]. They documented a number of different Bulletproof protocols, but not all of them in an obvious manner. This report chronologically numbers, summarizes and explain the different Bulletproof protocols in as simple terms as possible. It also simplifies the logic and explains the base mathematical concepts in more detail where prior knowledge was assumed. The report concludes with a discussion on an improved Bulletproof zero-knowledge proof protocol by some community members following an evolutionary approach.</p>
<a class="header" href="#contents" id="contents"><h2>Contents</h2></a>
<ul>
<li><a href="#the-bulletproof-protocols">The Bulletproof Protocols</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#preliminaries">Preliminaries</a>
<ul>
<li><a href="#notations-used">Notations Used</a></li>
<li><a href="#pedersen-commitments-and-elliptic-curve-pedersen-commitments">Pedersen Commitments and Elliptic Curve Pedersen Commitments</a></li>
<li><a href="#security-aspects-of-elliptic-curve-pedersen-commitments">Security aspects of (Elliptic Curve) Pedersen Commitments</a></li>
</ul>
</li>
<li><a href="#bulletproof-protocols">Bulletproof Protocols</a>
<ul>
<li><a href="#protocol-1---inner-product-argument">Protocol 1 - Inner-product Argument</a></li>
<li><a href="#protocol-2---inner-product-verification-through-multi-exponentiation">Protocol 2 - Inner-Product Verification through Multi-Exponentiation</a></li>
<li><a href="#protocol-2---range-proof-protocol-with-logarithmic-size">Protocol 2! - Range Proof Protocol with Logarithmic Size</a>
<ul>
<li><a href="#protocol-21---inner-product-range-proof">Protocol 2.1! - Inner-Product Range Proof</a></li>
<li><a href="#protocol-22---logarithmic-range-proof">Protocol 2.2! - Logarithmic Range Proof</a></li>
<li><a href="#protocol-23---aggregating-logarithmic-proofs">Protocol 2.3! - Aggregating Logarithmic Proofs</a></li>
<li><a href="#protocol-24---non-interactive-proof-through-fiat-shamir">Protocol 2.4! - Non-Interactive Proof through Fiat-Shamir</a></li>
<li><a href="#protocol-25---mpc-protocol-for-bulletproofs">Protocol 2.5! - MPC Protocol for Bulletproofs</a></li>
</ul>
</li>
<li><a href="#protocol-3---zero-knowledge-proof-for-arithmetic-circuits">Protocol 3! - Zero-Knowledge Proof for Arithmetic Circuits</a>
<ul>
<li><a href="#protocol-3---inner-product-proof-for-arithmetic-circuits">Protocol 3 - Inner-Product Proof for Arithmetic Circuits</a></li>
<li><a href="#protocol-31---logarithmic-sized-non-interactive-protocol-for-arithmetic-circuits">Protocol 3.1! - Logarithmic-Sized Non-Interactive Protocol for Arithmetic Circuits</a></li>
</ul>
</li>
<li><a href="#protocol-4---optimized-verifier-using-multi-exponentiation-and-batch-verification">Protocol 4! - Optimized Verifier using Multi-Exponentiation and Batch Verification</a></li>
</ul>
</li>
<li><a href="#evolving-bulletproof-protocols">Evolving Bulletproof Protocols</a></li>
<li><a href="#conclusions-observations-recommendations">Conclusions, Observations, Recommendations</a></li>
<li><a href="#references">References</a></li>
<li><a href="#appendices">Appendices</a>
<ul>
<li><a href="#appendix-a-definition-of-terms">Appendix A: Definition of Terms</a></li>
</ul>
</li>
<li><a href="#contributors">Contributors</a></li>
</ul>
</li>
</ul>
<a class="header" href="#preliminaries" id="preliminaries"><h2>Preliminaries</h2></a>
<a class="header" href="#notations-used" id="notations-used"><h3>Notations Used</h3></a>
<p>The general notation of mathematical expressions when specifically referenced are listed here, based on [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]. These notations are important pre-knowledge for the remainder of the report.</p>
<ul>
<li>Let  $ p $ and $ q $ be large prime numbers.</li>
<li>Let $ \mathbb G $ and $ \mathbb Q $ denote cyclic groups of prime order $ p $ and $ q $ respectively.</li>
<li>let $ \mathbb Z_p $ and $ \mathbb Z_q $ denote the ring of integers $ modulo \mspace{4mu} p $ and $ modulo \mspace{4mu} q $ respectively.</li>
<li>Let generators of $ \mathbb G $ be denoted by $ g, h, v, u \in \mathbb G $. In other words, there exists a number $ g \in \mathbb G  $ such that $  \mathbb G  = \lbrace 1 \mspace{3mu} , \mspace{3mu} g \mspace{3mu} , \mspace{3mu} g^2 \mspace{3mu} , \mspace{3mu} g^3 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu}  g^{p-1} \rbrace \equiv  \mathbb Z_p $. Note that not every element of $ \mathbb Z_p $ is a generator of $ \mathbb G $.</li>
<li>Let $ \mathbb Z_p^* $ denote $ \mathbb Z_p \setminus \lbrace 0 \rbrace $ and $ \mathbb Z_q^* $ denote $ \mathbb Z_q \setminus \lbrace 0 \rbrace $, that is all invertible elements of  $ \mathbb Z_p $ and $ \mathbb Z_q $ respectively. This excludes the element $ 0 $ which is not invertible.</li>
<li>Let $ \mathbb G^n $ and $ \mathbb Z^n_p $ be vector spaces of dimension $ n $ over $ \mathbb G $ and $ \mathbb Z_p $ respectively.</li>
<li>Let $ h^r \mathbf g^\mathbf x = h^r \prod_i g_i^{x_i} \in \mathbb G $ be the vector Pedersen Commitment<sup><a href="#pc" title="A Pedersen commitments is a system 
for making blinded non-interactive 
commitments to a value ...">def</a></sup> with $ \mathbf {g} = (g_1 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} g_n) \in \mathbb G^n $ and $ \mathbf {x} = (x_1 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} x_n) \in \mathbb G^n $.</li>
<li>Let $ \mathbf {a} \in \mathbb F^n $ be a vector with elements $ a_1 \cdot b_1 \mspace{3mu} , \mspace{3mu} . . . \mspace{3mu} , \mspace{3mu} a_n \cdot b_n \in F^n $.</li>
<li>Let $ \langle \mathbf {a}, \mathbf {b} \rangle = \sum _{i=1}^n {a_i \cdot b_i} $ denote the inner-product between two vectors $ \mathbf {a}, \mathbf {b} \in \mathbb F^n $.</li>
<li>Let $ \mathbf {a} \circ \mathbf {b} = (a_1 \cdot b_1 \mspace{3mu} , \mspace{3mu} . . . \mspace{3mu} , \mspace{3mu} a_n \cdot b_n) \in \mathbb F^n $ denote the entry wise multiplication of two vectors $ \mathbf {a}, \mathbf {b} \in \mathbb F^n $.</li>
<li>Let $ \mathbf {A} \circ \mathbf {B} = (a_{11} \cdot b_{11} \mspace{3mu} , \mspace{3mu} . . . \mspace{3mu} , \mspace{3mu} a_{1m} \cdot b_{1m} \mspace{6mu} ; \mspace{6mu} . . . \mspace{6mu} ; \mspace{6mu} a_{n1} \cdot b_{n1} \mspace{3mu} , \mspace{3mu} . . . \mspace{3mu} , \mspace{3mu} a_{nm} \cdot b_{nm} ) $ denote the entry wise multiplication of two matrixes, also known as the Hadamard Product<sup><a href="#hdmp" title="In mathematics, the Hadamard product 
is a binary operation that takes two 
matrices A,B of the same dimensions ...">def</a></sup>.</li>
<li>Let $ \mathbf {a} \parallel \mathbf {b} $ denote the concatenation of two vectors; if $ \mathbf {a} \in \mathbb Z_p^n $ and $ \mathbf {b} \in \mathbb Z_p^m $ then $ \mathbf {a} \parallel \mathbf {b} \in \mathbb Z_p^{n+m} $.</li>
<li>Let $ p(X) = \sum _{i=0}^d { \mathbf {p_i} \cdot X^i} \in \mathbb Z_p^n [X] $ be a vector polynomial where each coefficient $ \mathbf {p_i} $ is a vector in $ \mathbb Z_p^n $.</li>
<li>Let $ \langle l(X),r(X) \rangle = \sum _{i=0}^d { \sum _{j=0}^i { \langle l_i,r_i \rangle \cdot X^{i+j}}} \in \mathbb Z_p [X] $ denote the inner-product between two vector polynomials $ l(X),r(X) $.</li>
<li>Let $ t(X)=\langle l(X),r(X) \rangle $, then the inner-product is defined such that $ t(x)=\langle l(x),r(x) \rangle $ holds for all $ x \in \mathbb{Z_p} $.</li>
<li>Let $ C=g^a = \prod _{i=1}^n g_i^{a_i} \in \mathbb{G} $ be a binding (but not hiding) commitment to the vector $ \mathbf {a} \in \mathbb Z_p^n $ where $ \mathbf {g} = (g_1 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} g_n) \in \mathbb G^n $. Given vector $ \mathbf {b} \in \mathbb Z_p^n $ with non-zero entries, $ \mathbf {a} \circ \mathbf {b} $ is treated as a new commitment to $ C $. For this let $ g_i^\backprime =g_i^{(b_i^{-1})} $ such that $ C= \prod _{i=1}^n (g_i^\backprime)^{a_i \cdot b_i} $. The binding property of this new commitment is inherited from the old commitment.</li>
<li>Let slices of vectors be defined as $ \mathbf {a_{[:l]}} = (a_1 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} a_l) \in \mathbb F^l \mspace{3mu} , \mspace{12mu}\ \mathbf {a_{[l:]}} = (a_{l+1} \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} a_n) \in \mathbb F^{n-l}$.</li>
<li>Let $ \mathbf {k}^n $ denote the vector containing the first $ n $ powers of $ k \in \mathbb Z_p^* $ such that $ \mathbf {k}^n = (1,k,k^2, \mspace{3mu} ... \mspace{3mu} ,k^{n-1}) \in (\mathbb Z_p^*)^n $.</li>
<li>Let $ \mathcal{P} $ and $ \mathcal{V} $ denote the <em>prover</em> and <em>verifier</em> respectively.</li>
<li>Let $ \mathcal{P_{IP}} $ and $ \mathcal{V_{IP}} $ denote the <em>prover</em> and <em>verifier</em> in relation to inner-product calculations respectively.</li>
</ul>
<a class="header" href="#pedersen-commitments-and-elliptic-curve-pedersen-commitments" id="pedersen-commitments-and-elliptic-curve-pedersen-commitments"><h3>Pedersen Commitments and Elliptic Curve Pedersen Commitments</h3></a>
<p>The basis of confidential transactions is the Pedersen Commitment scheme defined by Pedersen T. [<a href="https://www.cs.cornell.edu/courses/cs754/2001fa/129.pdf" title="Non-interactive and information-theoretic
secure verifiable secret sharing, 
Pedersen T.">15</a>].</p>
<p>A commitment scheme in a Zero-knowledge Proof<sup><a href="#zk" title="In cryptography, a zero-knowledge 
proof/protocol is a method by which 
one party (the prover) can convince ...">def</a></sup> is a cryptographic primitive that allows a prover to commit to only a single chosen value/statement from a finite set without the ability to change it later (<em>binding</em> property) while keeping it hidden from a verifier (<em>hiding</em> property). Both <em>binding</em> and <em>hiding</em> properties are then further classified in increasing levels of security to be <em>computational</em>, <em>statistical</em> or <em>perfect</em>. On the one end of the scale <em>perfect</em> means that a quantum adversary (an attacker with infinite computing power) cannot tell what amount has been committed to and is also unable to produce fake commitments. <em>Statistical</em> means the probability for an adversary to do the same in a finite amount of time is negligible and the least secure, <em>computational</em>, means that no efficient algorithm running in a practical amount of time can reveal the commitment amount or produce fake commitments except with small probability. No commitment scheme can at the same time be perfectly <em>binding</em> and perfectly <em>hiding</em>.  ([<a href="https://en.wikipedia.org/wiki/Commitment_scheme" title="Wikipedia: Commitment scheme">12</a>], [<a href="http://cryptography.wikia.com/wiki/Commitment_scheme" title="Cryptography Wikia: Commitment scheme">13</a>])</p>
<p>Two variations of the Pedersen Commitment scheme sharing the same security attributes exist as defined below:</p>
<ul>
<li>
<p><u><i>Pedersen Commitment</i></u>:<a name="pc"> </a>The Pedersen Commitment is a system for making a blinded non-interactive commitment to a value. ([<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>], [<a href="https://blockstream.com/bitcoin17-final41.pdf" title="Confidential Assets,
Poelstra A. et al.,
Blockstream">3</a>], [<a href="https://hackage.haskell.org/package/pedersen-commitment" title="Pedersen-commitment: An implementation
of Pedersen commitment schemes">8</a>], [<a href="https://www.adjoint.io/docs/cryptography.html#pedersen-commitment-scheme" title="Adjoint Inc. Documentation: 
Pedersen Commitment Scheme">14</a>], [<a href="https://www.cs.cornell.edu/courses/cs754/2001fa/129.pdf" title="Non-interactive and information-theoretic
secure verifiable secret sharing, 
Pedersen T.">15</a>]).</p>
<ul>
<li>
<p>The generalized Pedersen Commitment definition follows (<em>refer to <a href="#notations-used">Notations Used</a></em>):</p>
<ul>
<li>
<p>Let $ q $ be a large prime and $ p $ be a large safe prime such that $ p = 2q + 1 $.</p>
</li>
<li>
<p>Let $ h $ be a random generator of cyclic group $ \mathbb G $ such that $ h $ is an element of $ \mathbb Z_q^* $.</p>
</li>
<li>
<p>Let $ a $ be a random value and element of $ \mathbb Z_q^* $ and calculate $ g $ such that $ g = h^a $.</p>
</li>
<li>
<p>Let $ r $ (the blinding factor) be a random value and element of $ \mathbb Z_p^* $.</p>
</li>
<li>
<p>The commitment to value $ x $ is then determined by calculating $ C(x,r) = h^r g^x $, which is called the Pedersen Commitment.</p>
</li>
<li>
<p>The generator $ h $ and resulting number $ g $ are known as the commitment bases and should be shared along with $ C(x,r) $ with whomever wishes to open the value.</p>
</li>
</ul>
</li>
<li>
<p>Pedersen Commitments are also additionally homomorphic, such that for messages $ x_0 $ and $ x_1 $ and blinding factors $ r_0 $ and $ r_1 $ we have $ C(x_0,r_0) \cdot C(x_1,r_1) = C(x_0+x_1,r_0+r_1) $</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><u><i>Elliptic Curve Pedersen Commitment</i></u>:<a name="ecpc"> </a>An efficient implementation of the Pedersen Commitment<sup><a href="#pc" title="A Pedersen commitments is a system 
for making blinded non-interactive 
commitments to a value ...">def</a></sup> will use secure Elliptic Curve Cryptography (ECC), which is based on the algebraic structure of elliptic curves over finite (prime) fields. Elliptic curve points are used as basic mathematical objects, instead of numbers. Note that traditionally in elliptic curve arithmetic lower case letters are used for ordinary numbers (integers) and upper case letters for curve points. ([<a href="http://cryptonite.info/files/HMBC.pdf" title="Homomorphic Mini-blockchain Scheme, 
Franca B., 
April 2015">26</a>], [<a href="http://orbilu.uni.lu/bitstream/10993/33705/1/MSPN2017.pdf" title="Efficient Implementation of Pedersen 
Commitments Using Twisted Edwards Curves, 
Franck C. and Großschädl J., 
University of Luxembourg">27</a>], [<a href="https://github.com/AdamISZ/ConfidentialTransactionsDoc/blob/master/essayonCT.pdf" title="An investigation into Confidential Transactions, 
Gibson A., 
July 2018">28</a>])
<ul>
<li>
<p>The generalized Elliptic Curve Pedersen Commitment definition follows (<em>refer to <a href="#notations-used">Notations Used</a></em>):</p>
<ul>
<li>
<p>Let $ \mathbb F_p $ be the group of elliptic curve points, where $ p $ is a large prime.</p>
</li>
<li>
<p>Let $ G \in  \mathbb F_p $ be a random generator point (base point) and let $ H \in  \mathbb F_p $ be specially chosen so that the value $ x_H $ to satisfy $ H = x_H G $ cannot be found except if the Elliptic Curve DLP (ECDLP) is solved.</p>
</li>
<li>
<p>Let $ r $ (the blinding factor) be a random value and element of $ \mathbb Z_p $.</p>
</li>
<li>
<p>The commitment to value $ x \in \mathbb Z_p $ is then determined by calculating $ C(x,r) = rH + xG $, which is called the Elliptic Curve Pedersen Commitment.</p>
</li>
</ul>
</li>
<li>
<p>Elliptic curve point addition is analogous to multiplication in the originally defined Pedersen Commitment<sup><a href="#pc" title="A Pedersen commitments is a system 
for making blinded non-interactive 
commitments to a value ...">def</a></sup>. Thus $ g^x $, the number $ g $ multiplied by itself $ m $ times, is analogous to $ xG $, the elliptic curve point $ G $ added to itself $ x $ times. In this context $ xG $ is also a point in $ \mathbb F_p $.</p>
</li>
<li>
<p>In the Elliptic Curve context $ C(x,r) = rH + xG $ is then analogous to  $ C(x,r) = h^r g^x $.</p>
</li>
<li>
<p>The number $ H $ is what is known as a Nothing Up My Sleeve (NUMS) number. With secp256k1 the value of $ H $ is the SHA256 hash of a simple encoding of the pre-specified generator point  $ G $.</p>
</li>
<li>
<p>Similar to Pedersen Commitments, the Elliptic Curve Pedersen Commitments are also additionally homomorphic, such that for messages $ x $, $ x_0 $ and $ x_1 $, blinding factors $ r $, $ r_0 $ and $ r_1 $ and scalar $ k $ the following relation holds: $ C(x_0,r_0) + C(x_1,r_1) = C(x_0+x_1,r_0+r_1) $ and $ C(k \cdot x, k \cdot r) = k \cdot C(x, r) $.</p>
</li>
<li>
<p>In secure implementations of ECC it is as hard to guess $ x $ from $ xG $ as it is to guess $ x $ from $g^x $. This is called the Elliptic Curve DLP (ECDLP).</p>
</li>
<li>
<p>Practical implementations usually consist of three algorithms: <code>Setup()</code> to set up the commitment parameters; <code>Commit()</code> to commit to the message using the commitment parameters and <code>Open()</code> to open and verify the commitment.</p>
</li>
</ul>
</li>
</ul>
<a class="header" href="#security-aspects-of-elliptic-curve-pedersen-commitments" id="security-aspects-of-elliptic-curve-pedersen-commitments"><h3>Security aspects of (Elliptic Curve) Pedersen Commitments</h3></a>
<p>By virtue of their definition Pedersen Commitments are only computationally <em>binding</em> but perfectly <em>hiding</em>. A simplified explanation follows.</p>
<p>If Alice wants to commit to a value $ x $ that will be sent to Bob who will at a later stage wants Alice to prove that the value $ x $ is the value that was used to generate the commitment $ C $, then Alice will select random blinding factor $ r $, calculate $ C(x,r) = h^r g^x $ and send that to Bob. Later Alice can reveal $ x $ and $ r $ and Bob can do the calculation and see that the commitment $ C $ it produces is the same as the one Alice sent earlier.</p>
<p>Perhaps Alice or Bob has managed to build a computer that can solve the DLP and given a public key could in reasonable time find alternate solutions to $ C(x,r) = h^r g^x $ in a reasonable time, that is $  C(x,r) =  h^{r^\prime} g^{x^\prime} $. This means even though Bob can find values for $ r^\prime $ and $ x^\prime $ that produce $ C $ he cannot know if those are the specific $ x $ and $ r $ that Alice chose, because there are so many that can produce the same $ C $. Pedersen Commitments are thus perfectly <em>hiding</em>.</p>
<p>Although the Pederson Commitment is perfectly <em>hiding</em> it does rely on the fact that Alice has NOT cracked the DLP to be able to calculate other pairs of input values to open the commitment to another value when challenged. The Pederson Commitment is thus only computationally <em>binding</em>.</p>
<a class="header" href="#bulletproof-protocols" id="bulletproof-protocols"><h2>Bulletproof Protocols</h2></a>
<p>Bulletproof protocols have multiple applications; most of these are discussed in <a href="../bulletproofs-and-mimblewimble/MainReport.html#applications-for-bulletproofs">Bulletproofs and Mimblewimble</a>. The list below links these use cases up with the different Bulletproof protocols:</p>
<ul>
<li>Bulletproofs provide short non-interactive zero-knowledge proofs without a trusted setup. The small size of Bulletproofs reduce overall cost. This has applicability in distributed systems where proofs are transmitted over a network or stored for a long time.</li>
<li><a href="#protocol-2---range-proof-protocol-with-logarithmic-size">Protocol 2!</a> provides short single and aggregatable range proofs and can be used with multiple blockchain protocols including Mimblewimble. These can be applied to normal transactions or to some smart contract where committed values need to be proven to be in a specific range without revealing the values.</li>
<li>The protocol presented in <a href="#protocol-23---aggregating-logarithmic-proofs">Protocol 2.3!</a> can be used for Merkle proofs and proof of solvency without revealing any additional information.</li>
<li>Range proofs can be compiled for a multi-party single joined confidential transaction for their known outputs using <a href="#protocol-25---mpc-protocol-for-bulletproofs">Protocol 2.5!</a>. Users do not have to reveal their secret transaction values.</li>
<li>Verifiable shuffles and multi-signatures with deterministic nonces can be implemented with <a href="#protocol-3---inner-product-proof-for-arithmetic-circuits">Protocol 3</a>.</li>
<li>Bulletproofs present an efficient and short zero-knowledge proof for arbitrary Arithmetic Circuits<sup><a href="#ac" title="An arithmetic circuit C over a 
field F and variables (x_1, ..., x_n) 
is a directed acyclic graph ...">def</a></sup> using <a href="#protocol-3---zero-knowledge-proof-for-arithmetic-circuits">Protocol 3!</a>.</li>
<li>Various Bulletproof protocols can be applied to scriptless scripts, to make them non-interactive and not having to use Sigma protocols.</li>
<li>Batch verifications can be done using <a href="#protocol-4---optimized-verifier-using-multi-exponentiation-and-batch-verification">Protocol 4!</a>, for example a blockchain full node receiving a block of transactions needs to verify all transactions as well as range proofs.</li>
</ul>
<p>A detailed mathematical discussion of the different Bulletproof protocols follows. Protocols 1, 2 and 3 are numbered consistently with [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>], whereas the rest of the protocols are numbered to fit chronologically with a faculty sign &quot;!&quot; to differentiate them. Refer to <a href="#notations-used">Notations Used</a>.</p>
<p><i><strong>Note:</strong> Full mathematical definitions and terms not defined are available in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>].</i>
<br></p>
<a class="header" href="#protocol-1---inner-product-argument" id="protocol-1---inner-product-argument"><h4>Protocol 1 - Inner-product Argument</h4></a>
<p>Protocol 1 is an argument of knowledge that the <em>prover</em> $ \mathcal{P} $ knows the openings of two binding Pedersen vector commitments that satisfy a given inner product relation. Let inputs to the inner-product argument be independent generators $ g,h \in \mathbb G^n $, a scalar $ c \in \mathbb Z_p $ and $ P \in \mathbb G $. The argument lets the <em>prover</em> $ \mathcal{P} $ convince a <em>verifier</em> $ \mathcal{V} $ that the <em>prover</em> $ \mathcal{P} $ knows two vectors $ \mathbf a, \mathbf b \in \mathbb Z^n_p $ such that</p>
<p>$$
P =g^ah^b \mspace{30mu} \mathrm{and} \mspace{30mu} c = \langle \mathbf {a} \mspace{3mu}, \mspace{3mu} \mathbf {b} \rangle
$$</p>
<p>$ P $ is referred to as the binding vector commitment to $ \mathbf a, \mathbf b $. The inner product argument is an efficient proof system for the following relation:</p>
<p>$$
{ (\mathbf {g},\mathbf {h} \in \mathbb G^n , \mspace{12mu} P \in \mathbb G , \mspace{12mu} c \in \mathbb Z_p ; \mspace{12mu} \mathbf {a}, \mathbf {b} \in \mathbb Z^n_p ) \mspace{3mu} : \mspace{15mu} P = g^\mathbf {a} h^\mathbf {b} \mspace{3mu} \wedge \mspace{3mu} c = \langle \mathbf {a} \mspace{3mu}, \mspace{3mu} \mathbf {b} \rangle } \mspace{100mu} (1)
$$</p>
<p>Relation (1) requires sending $ 2n $ elements to the <em>verifier</em> $ \mathcal{V} $. In order to send only $ 2 \log 2 (n) $ elements to the <em>verifier</em> $ \mathcal{V} $ for a given $ P \in \mathbb G $ the <em>prover</em> $ \mathcal{P} $ proves that it has vectors $ \mathbf {a}, \mathbf {b} \in \mathbb Z^n_p $ for which $ P =g^ah^b \cdot u^{ \langle \mathbf {a}, \mathbf {b} \rangle } $. Here $ u \in \mathbb G $ is a fixed group element with an unknown discrete-log relative to $ g,h \in \mathbb G^n $.</p>
<p>$$
{ (\mathbf {g},\mathbf {h} \in \mathbb G^n , \mspace{12mu} u,P \in \mathbb G ; \mspace{12mu} \mathbf {a}, \mathbf {b} \in \mathbb Z^n_p ) : \mspace{15mu} P =g^ah^b \cdot u^{ \langle \mathbf {a}, \mathbf {b} \rangle } } \mspace{100mu} (2)
$$</p>
<p>A proof system for relation (2) gives a proof system for (1) with the same complexity, thus only a proof system for relation (2) is required.</p>
<p>Protocol 1 is then defined as the proof system for relation (2) as shown in Figure 1. The element $ u $ is raised to a random power $ x $ chosen by the <em>verifier</em> $ \mathcal{V} $ to ensure that the extracted vectors $ \mathbf {a}, \mathbf {b} $ from <a href="#protocol-2---inner-product-verification-through-multi-exponentiation">Protocol 2</a> satisfy $ c = \langle \mathbf {a} \mspace{3mu} , \mspace{3mu} \mathbf {b} \rangle $.</p>
<p align="center"><img src="sources/Protocol-1.png" width="470" /></p>
<div align="center"><b>Figure&nbsp;1: Bulletproofs' Protocol 1 [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]</b></div>
<p>The argument presented in Protocol 1 has the following Commitment Scheme properties:</p>
<ul>
<li><u>Perfect completeness (hiding)</u>: Every validity/truth is provable, also see Definition 9 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>];</li>
<li><u>Statistical witness extended emulation (binding)</u>: Robust against either extracting a non-trivial discrete logarithm relation between $ \mathbf {g} , \mathbf {h} , u $ or extracting a valid witness $ \mathbf {a}, \mathbf {b} $.</li>
</ul>
<a class="header" href="#protocol-2---inner-product-verification-through-multi-exponentiation" id="protocol-2---inner-product-verification-through-multi-exponentiation"><h4>Protocol 2 - Inner-Product Verification through Multi-Exponentiation</h4></a>
<p>Protocol 2 performs inner-product verification through multi-exponentiation, the latter being a technique to reduce the number of computationally expensive exponentiations. The number of exponentiations is reduced to a single multi-exponentiation by delaying all the exponentiations until the last round. Protocol 2 has a logarithmic number of rounds and in each round the <em>prover</em> $ \mathcal{P} $ and <em>verifier</em> $ \mathcal{V} $ compute a new set of generators. By unrolling the recursion, the final $ g $ and $ h $ can be expressed in terms of the input generators $ \mathbf {g},\mathbf {h} \in \mathbb G^n $ as:</p>
<p>$$
g = \prod _{i=1}^n g_i^{s_i} \in \mathbb{G}, \mspace{21mu} h=\prod _{i=1}^n h_i^{1/s_i} \in \mathbb{G}
$$</p>
<p>where $ \mathbf {s} = (s_1 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} s_n) \in \mathbb Z_p^n $ only depends on the challenges $ (x_1 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} x_{\log_2(n)}) \in \mathbb Z_p^n $. The entire verification check in the protocol reduces to a single multi-exponentiation of size $ 2n + 2 \log_2(n) + 1 $:</p>
<p>$$
\mathbf g^{a \cdot \mathbf{s}} \cdot \mathbf h^{b \cdot\mathbf{s^{-1}}} \cdot u^{a \cdot b} \mspace{12mu} \overset{?}{=} \mspace{12mu} P \cdot \prod _{j=1}^{\log_2(n)} L_j^{x_j^2} \cdot R_j^{x_j^{-2}}
$$</p>
<p>with $ L $ and $R $ as defined in the original reference.</p>
<p>Protocol 2 is shown in Figure 2.</p>
<p align="center"><img src="sources/Protocol-2.png" width="570" /></p>
<div align="center"><b>Figure&nbsp;2: Bulletproofs' Protocol 2 [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]</b></div>
<a class="header" href="#protocol-2---range-proof-protocol-with-logarithmic-size" id="protocol-2---range-proof-protocol-with-logarithmic-size"><h4>Protocol 2! - Range Proof Protocol with Logarithmic Size</h4></a>
<p>Protocol 2! provides short and aggregatable range proofs, using the improved inner product argument from Protocol 1. It is build up in 5 parts:</p>
<ul>
<li>how to construct a range proof that requires the <em>verifier</em> $ \mathcal{V} $ to check an inner product between two vectors;</li>
<li>how to replace the inner product argument with an efficient inner-product argument;</li>
<li>how to efficiently aggregate $ m $ range proofs into one short proof;</li>
<li>how to make interactive public coin protocols non-interactive by using the Fiat-Shamir Heuristic<sup><a href="#fsh">def</a></sup> and</li>
<li>how to allow multiple parties to construct a single aggregate range proof.</li>
</ul>
<p>A diagrammatic overview of a range proof protocol implementation using Elliptic Curve Pedersen Commitments<sup><a href="#ecpc" title="An efficient implementation of the 
Pedersen Commitment  will use secure 
Elliptic Curve Cryptography, which is ...">def</a></sup> is given in Figure 3.</p>
<p align="center"><img src="sources/RangeProofDiagram.png" width="1000" /></p>
<div align="center"><b>Figure&nbsp;3: Range Proof Protocol Implementation Example [<a href="https://doc.dalek.rs/bulletproofs/index.html" title="Dalek Cryptography - 
Crate Bulletproofs">22</a>]</b></div>
<a class="header" href="#protocol-21---inner-product-range-proof" id="protocol-21---inner-product-range-proof"><h5>Protocol 2.1! - Inner-Product Range Proof</h5></a>
<p>This protocol provides the ability to construct a range proof that requires the <em>verifier</em> $ \mathcal{V} ​$ to check an inner product between two vectors. The range proof is constructed by exploiting the fact that a Pedersen Commitment $ V ​$ is an element in the same group $ \mathbb G ​$ that is used to perform the inner product argument. Let $ v \in \mathbb Z_p ​$ and let $ V \in \mathbb G ​$ be a Pedersen Commitment to $ v ​$ using randomness $ \gamma ​$. The proof system will convince the <em>verifier</em> $ \mathcal{V} ​$ that commitment $ V ​$ contains a number $ v \in [0,2^n - 1] ​$ such that</p>
<p>$$
{ (g,h \in \mathbb{G}) , V , n \mspace{3mu} ; \mspace{12mu} v, \gamma \in \mathbb{Z_p} ) \mspace{3mu} : \mspace{3mu} V =h^\gamma g^v \mspace{5mu} \wedge \mspace{5mu} v \in [0,2^n - 1] } \mspace{100mu} (3)
$$</p>
<p>without revealing $ v $. Let $ \mathbf {a}_L = (a_1 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} a_n) \in {0,1}^n $ be the vector containing the bits of $ v, $ so that $ \langle \mathbf {a}_L, \mathbf {2}^n \rangle = v $. The <em>prover</em> $ \mathcal{P} $ commits to $ \mathbf {a}_L $ using a constant size vector commitment $ A \in \mathbb{G} $. It will convince the <em>verifier</em> $ \mathcal{V} $ that $ v $ is in $ [0,2^n - 1] $ by proving that it knows an opening $ \mathbf {a}_L \in \mathbb Z_p^n $ of $ A $ and $ v, \gamma \in \mathbb{Z_p} $ such that $ V =h^\gamma g^v $ and</p>
<p>$$
\langle \mathbf {a}_L \mspace{3mu} , \mspace{3mu} \mathbf {2}^n \rangle = v \mspace{20mu} \mathrm{and} \mspace{20mu} \mathbf {a}_R = \mathbf {a}_L - \mathbf {1}^n \mspace{20mu} \mathrm{and} \mspace{20mu} \mathbf {a}_L \circ \mathbf {a}_R = \mathbf{0}^n \mspace{20mu} \mspace{100mu} (4)
$$</p>
<p>This proves that $ a_1 \mspace{3mu} , \mspace{3mu} ... \mspace{3mu} , \mspace{3mu} a_n $ are all in $ {0,1} $ and that $ \mathbf {a}_L $ is composed of the bits of $ v $. However, the $ 2n + 1 $ constraints needs to be expressed as a single inner-product constant so that <a href="#protocol-1---inner-product-argument">Protocol 1</a> can be used, by letting the <em>verifier</em> $ \mathcal{V} $ choose a random linear combination of the constraints. To prove that a committed vector $ \mathbf {b} \in \mathbb Z_p^n $ satisfies $ \mathbf {b} = \mathbf{0}^n $ it suffices for the <em>verifier</em> $ \mathcal{V} $ to send a random $ y \in \mathbb{Z_p} $ to the <em>prover</em> $ \mathcal{P} $ and for the <em>prover</em> $ \mathcal{P} $ to prove that $ \langle \mathbf {b}, \mathbf {y}^n \rangle = 0 $, which will convince the <em>verifier</em> $ \mathcal{V} $ that $ \mathbf {b} = \mathbf{0}^n $. The <em>prover</em> $ \mathcal{P} $ can thus prove relation (4) by proving that</p>
<p>$$
\langle \mathbf {a}_L \mspace{3mu} , \mspace{3mu} \mathbf {2}^n \rangle = v \mspace{20mu} \mathrm{and} \mspace{20mu} \langle \mathbf {a}_L - 1 - \mathbf {a}_R \mspace{3mu} , \mspace{3mu} \mathbf {y}^n \rangle=0 \mspace{20mu} \mathrm{and} \mspace{20mu} \langle \mathbf {a}_L \mspace{3mu} , \mspace{3mu} \mathbf {a}_R \circ \mathbf {y}^n \rangle = \mathbf{0}^n \mspace{20mu} \mspace{100mu} (5)
$$</p>
<p>Building on this, the <em>verifier</em> $ \mathcal{V} $ chooses a random $ z \in \mathbb{Z_p} $ and let the <em>prover</em> $ \mathcal{P} $ proves that</p>
<p>$$
z^2 \cdot \langle \mathbf {a}_L \mspace{3mu} , \mspace{3mu} \mathbf {2}^n \rangle + z \cdot \langle \mathbf {a}_L - 1 - \mathbf {a}_R \mspace{3mu} , \mspace{3mu} \mathbf {y}^n \rangle + \langle \mathbf {a}_L \mspace{3mu} , \mspace{3mu} \mathbf {a}_R \circ \mathbf {y}^n \rangle = z^2 \cdot v \mspace{20mu} \mspace{100mu} (6)
$$</p>
<p>Relation (6) can be rewritten as</p>
<p>$$
\langle \mathbf {a}_L - z \cdot \mathbf {1}^n \mspace{3mu} , \mspace{3mu} \mathbf {y}^n \circ (\mathbf {a}_R + z \cdot \mathbf {1}^n) +z^2 \cdot \mathbf {2}^n \rangle = z^2 \cdot v + \delta (y,z) \mspace{100mu} (7)
$$</p>
<p>where</p>
<p>$$
\delta (y,z) = (z-z^2) \cdot \langle \mathbf {1}^n \mspace{3mu} , \mspace{3mu} \mathbf {y}^n\rangle -z^3 \cdot \langle \mathbf {1}^n \mspace{3mu} , \mspace{3mu} \mathbf {2}^n\rangle \in \mathbb{Z_p}
$$</p>
<p>can be easily calculated by the <em>verifier</em> $ \mathcal{V} $. The proof that relation (4) holds was thus reduced to a single inner-product identity.</p>
<p>Relation (7) cannot be used in its current form without revealing information about $ \mathbf {a}_L $. Two additional blinding vectors $ \mathbf {s}_L , \mathbf {s}_R \in \mathbb Z_p^n $ are introduced with the <em>prover</em> $ \mathcal{P} $ and <em>verifier</em> $ \mathcal{V} $ engaging in the following zero-knowledge protocol (Figure 4):</p>
<p align="center"><img src="sources/Protocol-2b-part-a.png" width="550" /></p>
<div align="center"><b>Figure&nbsp;4: Bulletproofs' Protocol 2.1! Part A [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]</b></div>
<p>Two linear vector polynomials $ l(X), r(X) $ in $ \mathbb Z^n_p[X] $ are defined as the inner-product terms for relation (7), also containing the blinding vectors $ \mathbf {s}_L $ and $ \mathbf {s}_R $. A quadratic polynomial $ t(X) \in \mathbb Z_p[X] $ is then defined as the inner product between the two vector polynomials $ l(X), r(X) $ such that</p>
<p>$$
t(X) = \langle l(X) \mspace{3mu} , \mspace{3mu} r(X) \rangle = t_0 + t_1 \cdot X + t_2 \cdot X^2 \mspace{10mu} \in \mathbb {Z}_p[X]
$$</p>
<p>The blinding vectors $ \mathbf {s}_L $ and $ \mathbf {s}_R $ ensure that the <em>prover</em> $ \mathcal{P} $ can publish $ l(x) $ and $ r(x) $ for one $ x \in \mathbb Z_p^* $ without revealing any information about $ \mathbf {a}_L $ and $ \mathbf {a}_R $. The constant term $ t_0 $ of the quadratic polynomial $ t(X) $ is then the result of the inner product in relation (7), and the <em>prover</em> $ \mathcal{P} $ needs to convince the <em>verifier</em> $ \mathcal{V} $ that</p>
<p>$$
t_0 = z^2 \cdot v + \delta (y,z)
$$</p>
<p>In order to do so, the <em>prover</em> $ \mathcal{P} $ convinces the <em>verifier</em> $ \mathcal{V} $ that it has a commitment to the remaining coefficients of $ t(X) $, namely $ t_1,t_2 \in \mathbb Z_p $ by checking the value of $ t(X) $ at a random point $ x \in \mathbb Z_p^* $. This is illustrated in Figure 5.</p>
<p align="center"><img src="sources/Protocol-2b-part-b.png" width="655" /></p>
<div align="center"><b>Figure&nbsp;5: Bulletproofs' Protocol 2.1! Part B [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]</b></div>
<p>The <em>verifier</em> $ \mathcal{V} $ now needs to check that $ l $ and $ r $ are in fact $ l(x) $ and $ r(x) $ and that $ t(x) = \langle l \mspace{3mu} , \mspace{3mu} r \rangle $. A commitment for $ \mathbf {a}_R \circ \mathbf {y}^n $ is needed and to do so the commitment generators are switched from $ h \in \mathbb G^n $ to $ h ^\backprime = h^{(\mathbf {y}^{-1})}$. Thus $ A $ and $ S $ now become vector commitments to $ ( \mathbf {a}_L \mspace{3mu} , \mspace{3mu} \mathbf {a}_R \circ \mathbf {y}^n ) $ and $ ( \mathbf {s}_L \mspace{3mu} , \mspace{3mu} \mathbf {s}_R \circ \mathbf {y}^n ) $ respectively with respect to the new generators $ (g, h ^\backprime, h) $. This is illustrated in Figure 6.</p>
<p align="center"><img src="sources/Protocol-2b-part-c.png" width="640" /></p>
<div align="center"><b>Figure&nbsp;6: Bulletproofs' Protocol 2.1! Part C [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]</b></div>
<p>The range proof presented here has the following Commitment Scheme properties:</p>
<ul>
<li><u>Perfect completeness (hiding)</u>: Every validity/truth is provable, also see Definition 9 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>];</li>
<li><u>Perfect special honest verifier zero-knowledge</u>: The <em>verifier</em> $ \mathcal{V} $ behaves according to the protocol, also see Definition 12 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>];</li>
<li><u>Computational witness extended emulation (binding)</u>: A witness can be computed in time closely related to time spent by the <em>prover</em> $ \mathcal{P} $, also see Definition 10 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>].</li>
</ul>
<a class="header" href="#protocol-22---logarithmic-range-proof" id="protocol-22---logarithmic-range-proof"><h5>Protocol 2.2! - Logarithmic Range Proof</h5></a>
<p>This protocol replaces the inner product argument with an efficient inner-product argument. In step (63) Figure 5 the <em>prover</em> $ \mathcal{P} $ transmits $ \mathbf {l} $ and $ \mathbf {r} $ to the <em>verifier</em> $ \mathcal{V} $, but their size is linear in $ n $. To make this efficient a proof size that is logarithmic in $ n $ is needed. The transfer of $ \mathbf {l} $ and $ \mathbf {r} $ can be eliminated with an inner-product argument. Checking correctness of $ \mathbf {l} $ and $ \mathbf {r} $ (step (67) Figure 6) and $ \hat {t} $ (step (68) Figure 6) is the same as verifying that the witness $ \mathbf {l} , \mathbf {r} $ satisfies the inner product of relation (2) on public input $ (\mathbf {g} , \mathbf {h} ^ \backprime , P \cdot h^{-\mu}, \hat t) $. Transmission of vectors $ \mathbf {l} $ and $ \mathbf {r} $ to the <em>verifier</em> $ \mathcal{V} $ (step (63) Figure 5) can then be eliminated and transfer of information limited to the scalar properties $ ( \tau _x , \mu , \hat t ) $ alone, thereby archiving a proof size that is logarithmic in $ n $.</p>
<a class="header" href="#protocol-23---aggregating-logarithmic-proofs" id="protocol-23---aggregating-logarithmic-proofs"><h5>Protocol 2.3! - Aggregating Logarithmic Proofs</h5></a>
<p>This protocol efficiently aggregate $ m $ range proofs into one short proof with a slight modification to the protocol presented in <a href="#protocol-21---inner-product-range-proof">Protocol 2.1!</a>. For aggregate range proofs, the inputs of one range proof do not affect the output of another range proof. Aggregating logarithmic range proofs is especially helpful if a single <em>prover</em> $ \mathcal{P} $ needs to perform multiple range proofs at the same time.</p>
<p>A proof system must be presented for the following relation:
$$
{ (g,h \in \mathbb{G}) , \mspace{9mu} \mathbf {V} \in \mathbb{G}^m \mspace{3mu} ; \mspace{9mu} \mathbf {v}, \gamma \in \mathbb Z_p^m ) \mspace{6mu} : \mspace{6mu} V_j =h^{\gamma_j} g^{v_j} \mspace{6mu} \wedge \mspace{6mu} v_j \in [0,2^n - 1] \mspace{15mu} \forall \mspace{15mu} j \in [1,m] } \mspace{100mu} (8)
$$
The <em>prover</em> $ \mathcal{P} $ should now compute $ \mspace{3mu} \mathbf a_L \in \mathbb Z_p^{n \cdot m} $ as the concatenation of all of the bits for every $ v_j $ such that
$$
\langle \mathbf{2}^n \mspace{3mu} , \mspace{3mu} \mathbf a_L[(j-1) \cdot n : j \cdot n-1] \rangle = v_j \mspace{9mu} \forall \mspace{9mu} j \in [1,m] \mspace{3mu}
$$
The quantity $ \delta (y,z) $ is adjusted to incorporate more cross terms $ n \cdot m $ , the linear vector polynomials $ l(X), r(X) $ are adjusted to be in $ \mathbb Z^{n \cdot m}_p[X] $ and the blinding factor $ \tau_x $ for the inner product $ \hat{t} $ (step (61) Figure 5) is adjusted for the randomness of each commitment $ V_j $. The verification check (step (65) Figure 6) is updated to include all $ V_j $ commitments and the definition of $ P $ (step (66) Figure 6) is changed to be a commitment to the new $ r $.</p>
<p>This aggregated range proof that makes use of the inner product argument only uses $ 2 \cdot [ \log _2 (n \cdot m)] + 4 $ group elements and $ 5 $ elements in $ \mathbb Z_p $. The growth in size is limited to an additive term $ 2 \cdot [ \log _2 (m)] $ as opposed to a multiplicative factor $ m $ for $ m $ independent range proofs.</p>
<p>The aggregate range proof presented here has the following Commitment Scheme properties:</p>
<ul>
<li><u>Perfect completeness (hiding)</u>: Every validity/truth is provable, also see Definition 9 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>];</li>
<li><u>Perfect special honest verifier zero-knowledge</u>: The <em>verifier</em> $ \mathcal{V} $ behaves according to the protocol, also see Definition 12 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>];</li>
<li><u>Computational witness extended emulation (binding)</u>: A witness can be computed in time closely related to time spent by the <em>prover</em> $ \mathcal{P} $, also see Definition 10 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>].</li>
</ul>
<a class="header" href="#protocol-24---non-interactive-proof-through-fiat-shamir" id="protocol-24---non-interactive-proof-through-fiat-shamir"><h5>Protocol 2.4! - Non-Interactive Proof through Fiat-Shamir</h5></a>
<p>So far the <em>verifier</em> $ \mathcal{V} $ behaves as an honest verifier and all messages are random elements from $ \mathbb Z_p^* $. These are the pre-requisites needed to convert the protocol presented so far into a non-interactive protocol that is secure and has full zero-knowledge in the random oracle model (thus without a trusted setup) using the Fiat-Shamir Heuristic<sup><a href="#fsh" title="The Fiat–Shamir heuristic is a 
technique in cryptography to 
convert an interactive ...">def</a></sup>.</p>
<a class="header" href="#protocol-25---mpc-protocol-for-bulletproofs" id="protocol-25---mpc-protocol-for-bulletproofs"><h5>Protocol 2.5! - MPC Protocol for Bulletproofs</h5></a>
<p>This protocol allows multiple parties to construct a single simple efficient aggregate range proof designed for Bulletproofs. This is valuable when multiple parties want to create a single joined confidential transaction, where each party knows some of the inputs and outputs and needs to create range proofs for their known outputs. In Bulletproofs, $ m $ parties each having a Pedersen Commitment $ (V_k)_{k=1}^m $ can generate a single Bulletproof that each $ V_k $ commits to a number in some fixed range.</p>
<p>Let $ k $ denote the $ k $th party's message, thus $ A^{(k)} $ is generated using only inputs of party $ k $. A set of distinct generators $ (g^{(k)}, h^{(k)})^m_{k=1} $ is assigned to each party, and $ \mathbf g,\mathbf h $ is defined as the interleaved concatenation of all $ g^{(k)} , h^{(k)} $ such that</p>
<p>$$
g_i=g_{[{i \over{m}}]}^{((i-1) \mod m+1)} \mspace{15mu} \mathrm{and} \mspace{15mu} h_i=h_{[{i \over{m}}]}^{((i-1) \mod m+1)}
$$</p>
<p>The protocol either uses three rounds with linear communication in both $ m $ and the binary encoding of the range, or it uses a logarithmic number of rounds and communication that is only linear in $ m $. For the linear communication case the protocol in <a href="#protocol-21---inner-product-range-proof">Protocol 2.1!</a> is followed with the difference that each party generates its part of the proof using its own inputs and generators, that is</p>
<p>$$
A^{(k)} , S^{(k)}; \mspace{15mu} T_1^{(k)} , T_2^{(k)}; \mspace{15mu} \tau_x^{(k)} , \mu^{(k)} , \hat{t}^{(k)} , \mathbf{l}^{(k)} , \mathbf{r}^{(k)}
$$</p>
<p>These shares are sent to a dealer (could be anyone, even one of the parties) who adds them homomorphically to generate the respective proof components, for example</p>
<p>$$
A = \prod^m_{k=1} A^{(k)} \mspace{15mu} \mathrm{and} \mspace{15mu} \tau_x = \prod^m_{k=1} \tau_x^{(k)}
$$</p>
<p>In each round, the dealer generates the challenges using the Fiat-Shamir Heuristic<sup><a href="#fsh">def</a></sup> and the combined proof components and sends them to each party. In the end each party send $ \mathbf{l}^{(k)},\mathbf{r}^{(k)} $ to the dealer who computes $ \mathbf{l},\mathbf{r} $ as the interleaved concatenation of all shares. The dealer runs the inner product argument (<a href="#protocol-1---inner-product-argument">Protocol 1</a>) to generate the final proof. Each proof component is the (homomorphic) sum of each parties' proof components and each share constitutes part of a separate zero-knowledge proof. An example of the MPC protocol implementation using three rounds with linear communication is shown in Figure 7.</p>
<p align="center"><img src="sources/MPC-diagram.png" width="850" /></p>
<div align="center"><b>Figure&nbsp;7: MPC Implementation Example [<a href="https://doc-internal.dalek.rs/bulletproofs/aggregation/index.html" title="Dalek Cryptography - 
Module bulletproofs::aggregation">34</a>]</b></div>
<p>The communication can be reduced by running a second MPC protocol for the inner product argument, reducing the rounds to $ \log_2(l) $. Up to the last $ \log_2(l) $ round each parties' witnesses are independent and the overall witness is the interleaved concatenation of the parties' witnesses. The parties compute $ L^{(k)}, R^{(k)} $ in each round and the dealer computes $ L, R $ as the homomorphic sum of the shares. In the final round the dealer generates the final challenge and sends it to each party who in turn send their witness to the dealer who completes <a href="#protocol-2---inner-product-verification-through-multi-exponentiation">Protocol 2</a>.</p>
<a class="header" href="#protocol-3---zero-knowledge-proof-for-arithmetic-circuits" id="protocol-3---zero-knowledge-proof-for-arithmetic-circuits"><h4>Protocol 3! - Zero-Knowledge Proof for Arithmetic Circuits</h4></a>
<p>Bulletproofs present an efficient zero-knowledge argument for arbitrary Arithmetic Circuits<sup><a href="#ac" title="An arithmetic circuit C over a 
field F and variables (x_1, ..., x_n) 
is a directed acyclic graph ...">def</a></sup> with a proof size of $ 2 \cdot [ \log _2 (n)+13] $ elements with $ n $ denoting the multiplicative complexity (number of multiplication gates) of the circuit.</p>
<p>Bootle et al. [<a href="https://eprint.iacr.org/2016/263.pdf" title="Efficient zero-knowledge arguments for arithmetic 
circuits in the discrete log setting, Bootle J et al.">2</a>] showed how an arbitrary arithmetic circuit with $ n $ multiplication gates can be converted into a relation containing a Hadamard Product<sup><a href="#hdmp" title="In mathematics, the Hadamard product 
is a binary operation that takes two 
matrices A,B of the same dimensions ...">def</a></sup> relation with additional linear consistency constraints. The communication cost of the addition gates in the argument was removed by providing a technique that can directly handle a set of Hadamard products and linear relations together. For a two-input multiplication gate let $ \mathbf a_L , \mathbf a_R $ be the left and right input vectors respectively, then $ \mathbf a_L + \mathbf a_R = \mathbf a_O $ is the vector of outputs. Let $ Q \leqslant 2 \cdot n $ be the number of linear consistency constraints, $ \mathbf W_{L,q} \mspace{3mu} , \mathbf W_{R,q} \mspace{3mu}, \mathbf W_{O,q} \in \mathbb Z_p^n $ be the gate weights and $ c_q \in \mathbb Z_p $ for all $ q \in [1,Q] ​$, then the linear consistency constraints have the form</p>
<p>$$
\langle \mathbf W_{L,q}, \mathbf a_L \rangle + \langle \mathbf W_{R,q}, \mathbf a_R \rangle +\langle \mathbf W_{O,q}, \mathbf a_O \rangle = c_q
$$</p>
<p>The high-level idea of this protocol is to convert the Hadamard-product relation along with the linear consistency constraints into a single inner product relation. Pedersen Commitments $ V_j $ are also included as input wires to the arithmetic circuit, which is an important refinement otherwise the arithmetic circuit would need to implement a commitment algorithm. The linear constraints also include openings $ v_j $ of $ V_j $.</p>
<a class="header" href="#protocol-3---inner-product-proof-for-arithmetic-circuits" id="protocol-3---inner-product-proof-for-arithmetic-circuits"><h5>Protocol 3 - Inner-Product Proof for Arithmetic Circuits</h5></a>
<p>Similar to <a href="#protocol-21---inner-product-range-proof">Protocol 2.1!</a> the <em>prover</em> $ \mathcal{P} $ produces a random linear combination of the Hadamard Product<sup><a href="#hdmp" title="In mathematics, the Hadamard product 
is a binary operation that takes two 
matrices A,B of the same dimensions ...">def</a></sup> and linear constraints to form a single inner product constraint. If the combination is chosen randomly by the <em>verifier</em> $ \mathcal{V} $ then with overwhelming probability the inner-product constraint implies the other constraints. A proof system must be presented for relation (9) below:</p>
<p>$$
\begin{aligned}
\mspace{3mu} (g,h \in \mathbb{G} \mspace{3mu} ; \mspace{3mu} \mathbf g,\mathbf h \in \mathbb{G}^n \mspace{3mu} ; \mspace{3mu} \mathbf V \in \mathbb{G}^m \mspace{3mu} ; \mspace{3mu} \mathbf W_{L} , \mathbf W_{R} , \mathbf W_{O} \in \mathbb Z_p^{Q \times n} \mspace{3mu} ; \\
\mathbf W_{V} \in \mathbb Z_p^{Q \times m} \mspace{3mu} ; \mspace{3mu} \mathbb{c} \in \mathbb Z_p^{Q} \mspace{3mu} ; \mspace{3mu} \mathbf a_L , \mathbf a_R , \mathbf a_O \in \mathbb Z_p^{n} \mspace{3mu} ; \mspace{3mu} \mathbf v , \mathbf \gamma \in \mathbb Z_p^{m}) \mspace{3mu} : \mspace{15mu} \\
V_j =h^{\gamma_j} g^{v_j} \mspace{6mu} \forall \mspace{6mu} j \in [1,m] \mspace{6mu} \wedge \mspace{6mu} \mathbf a_L + \mathbf a_R = \mathbf a_O \mspace{6mu} \wedge \mspace{50mu} \\
\mathbf W_L \cdot \mathbf a_L + \mathbf W_R \cdot \mathbf a_R + \mathbf W_O \cdot \mathbf a_O = \mathbf W_V \cdot \mathbf v + \mathbf c \mspace{50mu}
\end{aligned}
\mspace{70mu} (9)
$$</p>
<p>Let $ \mathbf W_V \in \mathbb Z_p^{Q \times m} $ be the weights for a commitment $ V_j $. Relation (9) only holds when $ \mathbf W_{V} $ is of rank $ m $, i.e. if the columns of the matrix are all linearly independent.</p>
<p>Part 1 of the protocol is presented in Figure 8 where the <em>prover</em> $ \mathcal{P} $ commits to $ l(X),r(X),t(X) $.</p>
<p align="center"><img src="sources/Protocol-3-part-1.png" width="690" /></p>
<div align="center"><b>Figure&nbsp;8: Bulletproofs' Protocol 3 (Part 1) [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]</b></div>
<p>Part 2 of the protocol is presented in Figure 9 where the <em>prover</em> $ \mathcal{P} $ convinces the <em>verifier</em> $ \mathcal{V} $ that the polynomials are well formed and that $ \langle l(X),r(X) \rangle = t(X) $.</p>
<p align="center"><img src="sources/Protocol-3-part-2.png" width="690" /></p>
<div align="center"><b>Figure&nbsp;9: Bulletproofs' Protocol 3 (Part 2) [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]</b></div>
<p>The proof system presented here has the following Commitment Scheme properties:</p>
<ul>
<li><u>Perfect completeness (hiding)</u>: Every validity/truth is provable, also see Definition 9 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>];</li>
<li><u>Perfect honest verifier zero-knowledge</u>: The <em>verifier</em> $ \mathcal{V} $ behaves according to the protocol, also see Definition 12 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>];</li>
<li><u>Computational witness extended emulation (binding)</u>: A witness can be computed in time closely related to time spent by the <em>prover</em> $ \mathcal{P} $, also see Definition 10 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>].</li>
</ul>
<a class="header" href="#protocol-31---logarithmic-sized-non-interactive-protocol-for-arithmetic-circuits" id="protocol-31---logarithmic-sized-non-interactive-protocol-for-arithmetic-circuits"><h5>Protocol 3.1! - Logarithmic-Sized Non-Interactive Protocol for Arithmetic Circuits</h5></a>
<p>Similar to <a href="#protocol-22---logarithmic-range-proof">Protocol 2.2!</a> the communication cost of <a href="#protocol-3---inner-product-proof-for-arithmetic-circuits">Protocol 3</a> can be reduced by using the efficient inner product argument. Transmission of vectors $ \mathbf {l} $ and $ \mathbf {r} $ to the <em>verifier</em> $ \mathcal{V} $ (step (82) Figure 9) can be eliminated and transfer of information limited to the scalar properties $ ( \tau _x , \mu , \hat t ) $ alone. The <em>prover</em> $ \mathcal{P} $ and <em>verifier</em> $ \mathcal{V} $ engage in an inner product argument on public input $ (\mathbf {g} , \mathbf {h} ^ \backprime , P \cdot h^{-\mu}, \hat t) $ to check correctness of $ \mathbf {l} $ and $ \mathbf {r} $ (step (92) Figure 9) and $ \hat {t} $ (step (88) Figure 9); this is the same as verifying that the witness $ \mathbf {l} , \mathbf {r} $ satisfies the inner product of relation. Communication is now reduced to $ 2 \cdot [ \log_22(n)] + 8 $ group elements and $ 5 $ elements in $ \mathbb Z $ instead of $ 2 \cdot n $ elements, thereby archiving a proof size that is logarithmic in $ n $.</p>
<p>Similar to <a href="#protocol-24---non-interactive-proof-through-fiat-shamir">Protocol 2.4!</a> the protocol presented so far can be turned into an efficient non interactive proof that is secure and full zero-knowledge in the random oracle model (thus without a trusted setup) using the Fiat-Shamir Heuristic<sup><a href="#fsh" title="The Fiat–Shamir heuristic is a 
technique in cryptography to 
convert an interactive ...">def</a></sup>.</p>
<p>The proof system presented here has the following Commitment Scheme properties:</p>
<ul>
<li><u>Perfect completeness (hiding)</u>: Every validity/truth is provable, also see Definition 9 in [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>];</li>
<li><u>Statistical zero-knowledge</u>: The <em>verifier</em> $ \mathcal{V} $ behaves according to the protocol and $ \mathbf {l} , \mathbf {r} $ can be efficiently simulated;</li>
<li><u>Computational soundness (binding)</u>: if the generators $ \mathbf {g} , \mathbf {h} , g , h $ are independently generated, then finding a discrete logarithm relation between them is as hard as breaking the Discrete Log Problem.</li>
</ul>
<a class="header" href="#protocol-4---optimized-verifier-using-multi-exponentiation-and-batch-verification" id="protocol-4---optimized-verifier-using-multi-exponentiation-and-batch-verification"><h4>Protocol 4! - Optimized Verifier using Multi-Exponentiation and Batch Verification</h4></a>
<p>In many of the Bulletproofs' <a href="../bulletproofs-and-mimblewimble/MainReport.html#applications-for-bulletproofs">Use Cases</a> the <em>verifier's</em> runtime is of particular interest. This protocol presents optimizations for a single range proof that is also extendable to aggregate range proofs (<a href="#protocol-23---aggregating-logarithmic-proofs">Protocol 2.3!</a>) and the arithmetic circuit protocol (<a href="#protocol-3---zero-knowledge-proof-for-arithmetic-circuits">Protocol 3!</a>).</p>
<p><u>Multi-exponentiation</u></p>
<p>In <a href="#protocol-2---inner-product-verification-through-multi-exponentiation">Protocol 2</a> verification of the inner-product is reduced to a single multi-exponentiation. This can be extended to verify the whole range proof using a single multi-exponentiation of size $ 2n + \log_2(n) + 7 $. In <a href="#protocol-2---inner-product-verification-through-multi-exponentiation">Protocol 2</a> the Bulletproof <em>verifier</em> $ \mathcal{V} $ only performs two checks, that is step (68) Figure 6 and step (16) Figure 2.</p>
<p>In the protocol presented in Figure 10, that is processed by the <em>verifier</em> $ \mathcal{V} $, $ x_u $ is the challenge from <a href="#protocol-1---inner-product-argument">Protocol 1</a>, $ x_j $ the challenge from round $ j $ of <a href="#protocol-2---inner-product-verification-through-multi-exponentiation">Protocol 2</a>, and $ L_j , R_j $ the $ L , R $ values from round $ j $ of <a href="#protocol-2---inner-product-verification-through-multi-exponentiation">Protocol 2</a>.</p>
<p align="center"><img src="sources/Protocol-4.png" width="570" /></p>
<div align="center"><b>Figure&nbsp;10: Bulletproofs' Protocol 4! [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>]</b></div>
<p>A further idea is that multi-exponentiation (steps (98) and (105) in Figure 10) be delayed until those checks are performed and that they are also combined into a single check using a random value $ c \xleftarrow[]{$} \mathbf Z_p $. This follows from the fact that if $ A^cB = 1 $ for a random $ c $ then with high probability $ A = 1 \mspace 3mu \wedge \mspace 3mu B = 1 $. Various algorithms are known to compute the multi-exponentiations and scalar quantities (steps (101) and (102) in Figure 10) efficiently (sub-linearly), thereby further improving the speed and efficiency of the protocol.</p>
<p><u>Batch verification</u></p>
<p>A further important optimization concerns the verification of multiple proofs. The essence of the verification is to calculate a large multi-exponentiation. Batch verification is applied in order to reduce the number of expensive exponentiations. This is based on the observation that checking $ g^x = 1 \mspace 3mu \wedge \mspace 3mu g^y = 1 $ can be checked by drawing a random scalar $ \alpha $ from a large enough domain and checking that $ g^{\alpha x + y} = 1 $. With high probability, the latter equation implies the first. When applied to multi-exponentiations, $ 2n $ exponentiations can be saved per additional proof. Verifying $ m $ distinct range proofs of size $ n $ only requires a single multi-exponentiation of size $ 2n+2+m \cdot (2 \cdot \log (n) + 5 ) $ along with $ O ( m \cdot n ) $ scalar operations.</p>
<a class="header" href="#evolving-bulletproof-protocols" id="evolving-bulletproof-protocols"><h2>Evolving Bulletproof Protocols</h2></a>
<p>Interstellar [<a href="https://interstellar.com" title="Inter/stellar Website">24</a>] recently introduced the Programmable Constraint Systems for Bulletproofs [<a href="https://medium.com/interstellar/programmable-constraint-systems-for-bulletproofs-365b9feb92f7" title="Programmable Constraint Systems for Bulletproofs,
Interstellar,
Cathie Yun">23</a>], an evolution of <a href="#protocol-3---zero-knowledge-proof-for-arithmetic-circuits">Protocol 3!</a>, extending it to support proving arbitrary statements in zero-knowledge using a constraint system, bypassing arithmetic circuits altogether. They provide an Application Programmers Interface (API) for building a constraint system directly, without the need to construct arithmetic expressions and then transform them into constraints. The Bulletproof constraint system proofs are then used as building blocks for a confidential assets protocol called Cloak.</p>
<p>The constraint system has three kinds of variables:</p>
<ul>
<li>High-level witness variables:
<ul>
<li>Known only to the <em>prover</em> $ \mathcal{P} $, as external inputs to the constraint system;</li>
<li>Represented as individual Pedersen Commitments to the external variables in Bulletproofs.</li>
</ul>
</li>
<li>Low-level witness variables:
<ul>
<li>Known only to the <em>prover</em> $ \mathcal{P} $, as internal to the constraint system;</li>
<li>Representing the inputs and outputs of the multiplication gates.</li>
</ul>
</li>
<li>Instance variables:
<ul>
<li>Known to both the <em>prover</em> $ \mathcal{P} $ and the <em>verifier</em> $ \mathcal{V} $, as public parameters;</li>
<li>Represented as a family of constraint systems parameterized by public inputs (compatible with Bulletproofs);</li>
<li>Folding all instance variables into a single constant parameter internally.</li>
</ul>
</li>
</ul>
<p>Instance variables can select the constraint system out of a family for each proof. The constraint system becomes a challenge from a <em>verifier</em> $ \mathcal{V} $ to a <em>prover</em> $ \mathcal{P} $, where some constraints are generated randomly in response to the <em>prover</em>'s $ \mathcal{P} $ commitments. Challenges to parametrize constraint systems makes the resulting proof smaller, requiring only $ O(n) $ multiplications instead of $ O(n^2) $ in the case of verifiable shuffles when compared to a static constraint system.</p>
<p>Merlin transcripts [<a href="https://doc.dalek.rs/merlin/index.html" title="Dalek Cryptography - 
Crate merlin">25</a>] employing the Fiat-Shamir Heuristic<sup><a href="#fsh" title="The Fiat–Shamir heuristic is a 
technique in cryptography to 
convert an interactive ...">def</a></sup> are used to generate the challenges. The challenges are bound to the high-level witness variables (the external inputs to the constraint system) which are added to the transcript before any of the constraints are created. The <em>prover</em> $ \mathcal{P} $ and <em>verifier</em> $ \mathcal{V} $ can then compute weights for some constraints with the use of the challenges.</p>
<p>Because the challenges are not bound to low-level witness variables the resulting construction can be unsafe. Interstellar are working on an improvement to the protocol that would allow challenges to be bound to a subset of the low-level witness variables, and have a safer API using features of Rust’s type system.</p>
<p>The resulting API provides a single code path used by both the <em>prover</em> $ \mathcal{P} $ and <em>verifier</em> $ \mathcal{V} $ to allocate variables and define constraints. This is organized into a hierarchy of task-specific gadgets, which manages allocation, assignment and constraints on the variables, ensuring that all variables are constrained. Gadgets interact with mutable constraint system objects, which are specific to the <em>prover</em> $ \mathcal{P} $ and <em>verifier</em> $ \mathcal{V} $. They also receive secret variables and public parameters and generate challenges.</p>
<p>The Bulletproofs library [<a href="https://doc.dalek.rs/bulletproofs/index.html" title="Dalek Cryptography - 
Crate Bulletproofs">22</a>] does not provide any standard gadgets, but only an API for the constraint system. Each protocol built on top of the Bulletproofs library must create its own collection of gadgets to enable building a complete constraint system out of them. The Interstellar Bulletproof zero-knowledge proof protocol built with their programmable constraint system is shown in Figure 11.</p>
<p align="center"><img src="sources/InterstellarConstraintSystem.png" width="870" /></p>
<div align="center"><b>Figure&nbsp;11: Interstellar Bulletproof Zero-Knowledge Proof Protocol [<a href="https://medium.com/interstellar/programmable-constraint-systems-for-bulletproofs-365b9feb92f7" title="Programmable Constraint Systems for Bulletproofs,
Interstellar,
Cathie Yun">24</a>]</b></div>
<a class="header" href="#conclusions-observations-recommendations" id="conclusions-observations-recommendations"><h2>Conclusions, Observations, Recommendations</h2></a>
<ul>
<li>Bulletproofs have many potential use cases or <a href="../bulletproofs-and-mimblewimble/MainReport.html#applications-for-bulletproofs">applications</a>, but are still under <a href="../bulletproofs-and-mimblewimble/MainReport.html#current--past-efforts">development</a>. A new confidential blockchain protocol like Tari should carefully consider expanded use of Bulletproofs to maximally leverage functionality of the code base.</li>
<li>Bulletproofs are not done yet, as illustrated in <a href="#evolving-bulletproof-protocols">Evolving Bulletproof Protocols</a>, and its further development and efficient implementation has a lot of traction in the community.</li>
<li>Bünz et al. [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>] proposed that the switch commitment scheme defined by Ruffing et al. [<a href="https://eprint.iacr.org/2017/237.pdf" title="Switch Commitments: A Safety Switch 
for Confidential Transactions, 
Ruffing T. et al.">10</a>] can be used for Bulletproofs if doubts in the underlying cryptographic hardness (discrete log) assumption arise in future. The switch commitment scheme allows for a blockchain with proofs that are currently only computationally binding to later switch to a proof system that is perfectly binding and secure against quantum adversaries; this will weaken the perfectly hiding property as a drawback and slow down all proof calculations. In the Bünz et al. [<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>] proposal all Pedersen Commitments will be replaced with ElGamal Commitments<sup><a href="#egc" title="An ElGamal Commitment is a 
Pedersen Commitment with
additional commitment ...">def</a></sup> to move from computationally binding to perfectly binding. They also gave further ideas about how the ElGamal commitments can possibly be enhanced to improve the hiding property to be statistical or perfect. (<em>See the Grin projects' implementation <a href="../bulletproofs-and-mimblewimble/MainReport.html#wallet-reconstruction-and-switch-commitment---grin">here</a>.</em>)</li>
<li>It is important that developers understand more about the fundamental underlying mathematics when implementing something like Bulletproofs, even if they just re-use libraries developed by someone else.</li>
</ul>
<a class="header" href="#references" id="references"><h2>References</h2></a>
<p>[<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>] Bulletproofs: Short Proofs for Confidential Transactions and More, Blockchain Protocol Analysis and Security Engineering 2018, Bünz B., Bootle J., Boneh D., Poelstra A., Wuille P. and Maxwell G., http://web.stanford.edu/~buenz/pubs/bulletproofs.pdf, Date accessed: 2018-09-18.</p>
<p>[<a href="https://eprint.iacr.org/2016/263.pdf" title="Efficient zero-knowledge arguments for arithmetic 
circuits in the discrete log setting, Bootle J et al.">2</a>] Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting, Bootle J., Cerulli A., Chaidos P., Groth J. and Petit C., Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 327-357. Springer, 2016., https://eprint.iacr.org/2016/263.pdf, Date accessed: 2018-09-21.</p>
<p>[<a href="https://blockstream.com/bitcoin17-final41.pdf" title="Confidential Assets,
Poelstra A. et al.,
Blockstream">3</a>] Confidential Assets, Poelstra A., Back A., Friedenbach M., Maxwell G. and Wuille P., Blockstream, https://blockstream.com/bitcoin17-final41.pdf, Date accessed: 2018-09-25.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof" title="Wikipedia - Zero-knowledge Proof">4</a>] Wikipedia: Zero-knowledge Proof, https://en.wikipedia.org/wiki/Zero-knowledge_proof, Date accessed: 2018-09-18.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Discrete_logarithm" title="Wikipedia: Discrete logarithm">5</a>] Wikipedia: Discrete logarithm, https://en.wikipedia.org/wiki/Discrete_logarithm, Date accessed: 2018-09-20.</p>
<p>[<a href="https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf" title="How to Prove Yourself: Practical Solutions to 
Identification and Signature Problems, 
Fiat A. et al.">6</a>] How to Prove Yourself: Practical Solutions to Identification and Signature Problems, Fiat A. and Shamir A., CRYPTO 1986: pp. 186-194, https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf, Date accessed: 2018-09-20.</p>
<p>[<a href="https://link.springer.com/content/pdf/10.1007%2F978-3-642-34961-4_38.pdf" title="How not to Prove Yourself: Pitfalls of the 
Fiat-Shamir Heuristic and Applications to Helios, 
Bernhard D. et al.">7</a>] How not to Prove Yourself: Pitfalls of the Fiat-Shamir Heuristic and Applications to Helios, Bernhard D., Pereira O. and Warinschi B., https://link.springer.com/content/pdf/10.1007%2F978-3-642-34961-4_38.pdf, Date accessed: 2018-09-20.</p>
<p>[<a href="https://hackage.haskell.org/package/pedersen-commitment" title="Pedersen-commitment: An implementation
of Pedersen commitment schemes">8</a>] Pedersen-commitment: An implementation of Pedersen commitment schemes, https://hackage.haskell.org/package/pedersen-commitment, Date accessed: 2018-09-25.</p>
<p>[<a href="https://zkproof.org/documents.html" title="Zero Knowledge Proof Standardization - 
An Open Industry/Academic Initiative">9</a>] Zero Knowledge Proof Standardization - An Open Industry/Academic Initiative, https://zkproof.org/documents.html, Date accessed: 2018-09-26.</p>
<p>[<a href="https://eprint.iacr.org/2017/237.pdf" title="Switch Commitments: A Safety Switch 
for Confidential Transactions, 
Ruffing T. et al.">10</a>] Switch Commitments: A Safety Switch for Confidential Transactions, Ruffing T. and Malavolta G., https://eprint.iacr.org/2017/237.pdf, Date accessed: 2018-09-26.</p>
<p>[<a href="https://github.com/adjoint-io/bulletproofs" title="GitHub: adjoint-io/Bulletproofs, Bulletproofs are Short
Non-interactive Zero-knowledge Proofs that Require 
no Trusted Setup">11</a>] GitHub: adjoint-io/Bulletproofs, Bulletproofs are Short Non-interactive Zero-knowledge Proofs that Require no Trusted Setup, https://github.com/adjoint-io/Bulletproofs, Date accessed: 2018-09-10.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Commitment_scheme" title="Wikipedia: Commitment scheme">12</a>] Wikipedia: Commitment scheme, https://en.wikipedia.org/wiki/Commitment_scheme, Date accessed: 2018-09-26.</p>
<p>[<a href="http://cryptography.wikia.com/wiki/Commitment_scheme" title="Cryptography Wikia: Commitment scheme">13</a>] Cryptography Wikia: Commitment scheme, http://cryptography.wikia.com/wiki/Commitment_scheme, Date accessed: 2018-09-26.</p>
<p>[<a href="https://www.adjoint.io/docs/cryptography.html#pedersen-commitment-scheme" title="Adjoint Inc. Documentation: 
Pedersen Commitment Scheme">14</a>] Adjoint Inc. Documentation: Pedersen Commitment Scheme, https://www.adjoint.io/docs/cryptography.html#pedersen-commitment-scheme, Date accessed: 2018-09-27.</p>
<p>[<a href="https://www.cs.cornell.edu/courses/cs754/2001fa/129.pdf" title="Non-interactive and information-theoretic
secure verifiable secret sharing, 
Pedersen T.">15</a>] Non-interactive and information-theoretic secure verifiable secret sharing, Pedersen T., https://www.cs.cornell.edu/courses/cs754/2001fa/129.pdf, Date accessed: 2018-09-27.</p>
<p>[<a href="http://www.semper.org/sirene/publ/SaSt_01.dh-et-al.long.pdf" title="Assumptions Related to Discrete Logarithms: 
Why Subtleties Make a Real Difference, 
Sadeghi A et al.">16</a>] Assumptions Related to Discrete Logarithms: Why Subtleties Make a Real Difference, Sadeghi A. and Steiner M., http://www.semper.org/sirene/publ/SaSt_01.dh-et-al.long.pdf, Date accessed: 2018-09-24.</p>
<p>[<a href="http://www.e-ijaet.org/media/58I6-IJAET0612695.pdf" title="Intensified ElGamal Cryptosystem (IEC), Sharma P. et al.
International Journal of Advances in Engineering &amp; Technology,
Jan 2012">17</a>] Intensified ElGamal Cryptosystem (IEC), Sharma P., Gupta A. and Sharma S., International Journal of Advances in Engineering &amp; Technology, Jan 2012, http://www.e-ijaet.org/media/58I6-IJAET0612695.pdf, Date accessed: 2018-10-09.</p>
<p>[<a href="https://drive.google.com/file/d/16XGAByoXse5NQl57v_GldJwzmvaQlS94/view" title="On the Security of ElGamal Based Encryption,
Tsiounis Y. et al.">18</a>] On the Security of ElGamal Based Encryption, Tsiounis Y. and Yung M., https://drive.google.com/file/d/16XGAByoXse5NQl57v_GldJwzmvaQlS94/view, Date accessed: 2018-10-09.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption" title="Wikipedia: Decisional Diffie–Hellman assumption">19</a>] Wikipedia: Decisional Diffie–Hellman assumption, https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption, Date accessed: 2018-10-09.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Arithmetic_circuit_complexity" title="Wikipedia: Arithmetic circuit complexity">20</a>] Wikipedia: Arithmetic circuit complexity, https://en.wikipedia.org/wiki/Arithmetic_circuit_complexity, Date accessed: 2018-11-08.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)" title="Wikipedia: Hadamard product (matrices)">21</a>] Wikipedia: Hadamard product (matrices), https://en.wikipedia.org/wiki/Hadamard_product_(matrices), Date accessed: 2018-11-12.</p>
<p>[<a href="https://doc.dalek.rs/bulletproofs/index.html" title="Dalek Cryptography - 
Crate Bulletproofs">22</a>] Dalek Cryptography - Crate Bulletproofs, https://doc.dalek.rs/bulletproofs/index.html, Date accessed: 2018-11-12.</p>
<p>[<a href="https://medium.com/interstellar/programmable-constraint-systems-for-bulletproofs-365b9feb92f7" title="Programmable Constraint Systems for Bulletproofs,
Interstellar,
Cathie Yun">23</a>] Programmable Constraint Systems for Bulletproofs, https://medium.com/interstellar/programmable-constraint-systems-for-bulletproofs-365b9feb92f7, Date accessed: 2018-11-22.</p>
<p>[<a href="https://interstellar.com" title="Inter/stellar Website">24</a>] Inter/stellar website, https://interstellar.com, Date accessed: 2018-11-22.</p>
<p>[<a href="https://doc.dalek.rs/merlin/index.html" title="Dalek Cryptography - 
Crate merlin">25</a>] Dalek Cryptography - Crate merlin, https://doc.dalek.rs/merlin/index.html, Date accessed: 2018-11-22.</p>
<p>[<a href="http://cryptonite.info/files/HMBC.pdf" title="Homomorphic Mini-blockchain Scheme, 
Franca B., 
April 2015">26</a>] Homomorphic Mini-blockchain Scheme, Franca B., April 2015, http://cryptonite.info/files/HMBC.pdf, Date accessed: 2018-11-22.</p>
<p>[<a href="http://orbilu.uni.lu/bitstream/10993/33705/1/MSPN2017.pdf" title="Efficient Implementation of Pedersen 
Commitments Using Twisted Edwards Curves, 
Franck C. and Großschädl J., 
University of Luxembourg">27</a>] Efficient Implementation of Pedersen Commitments Using Twisted Edwards Curves, Franck C. and Großschädl J., University of Luxembourg, http://orbilu.uni.lu/bitstream/10993/33705/1/MSPN2017.pdf, Date accessed: 2018-11-22.</p>
<p>[<a href="https://github.com/AdamISZ/ConfidentialTransactionsDoc/blob/master/essayonCT.pdf" title="An investigation into Confidential Transactions, 
Gibson A., 
July 2018">28</a>] An investigation into Confidential Transactions, Gibson A., July 2018, https://github.com/AdamISZ/ConfidentialTransactionsDoc/blob/master/essayonCT.pdf, Date accessed: 2018-11-22.</p>
<a class="header" href="#appendices" id="appendices"><h2>Appendices</h2></a>
<a class="header" href="#appendix-a-definition-of-terms" id="appendix-a-definition-of-terms"><h3>Appendix A: Definition of Terms</h3></a>
<p>Definitions of terms presented here are high level and general in nature. Full mathematical definitions are available in the cited references.</p>
<ul>
<li><u><i>Arithmetic Circuits</i></u>:<a name="ac"> </a>An arithmetic circuit $ C $ over a field $ F $ and variables $ (x_1, ..., x_n) $ is a directed acyclic graph whose vertices are called gates. Arithmetic circuits can alternatively be described as a list of addition and multiplication gates with a collection of linear consistency equations relating the inputs and outputs of the gates. The size of an arithmetic circuit is the number of gates in it, with the depth being the length of the longest directed path. <em>Upper bounding</em> the complexity of a polynomial $ f $ is to find any arithmetic circuit that can calculate $ f $, whereas <em>lower bounding</em> is to find the smallest arithmetic circuit that can calculate $ f $. An example of a simple arithmetic circuit with size six and depth two that calculates a polynomial is shown below. ([<a href="https://github.com/adjoint-io/bulletproofs" title="GitHub: adjoint-io/Bulletproofs, Bulletproofs are Short
Non-interactive Zero-knowledge Proofs that Require 
no Trusted Setup">11</a>], [<a href="https://en.wikipedia.org/wiki/Arithmetic_circuit_complexity" title="Wikipedia: Arithmetic circuit complexity">20</a>])</li>
</ul>
 <p align="center"><img src="sources/ArithmiticCircuit.png" width="300" /></p>
<ul>
<li><i><u>Discrete Logarithm/Discrete Logarithm Problem (DLP)</u></i>:<a name="dlp"> </a>In the mathematics of real numbers, the logarithm $ \log_b^a ​$ is a number $ x ​$ such that $ b^x=a ​$, for given numbers $ a ​$ and $ b ​$. Analogously, in any group $ G ​$ , powers $ b^k ​$ can be defined for all integers $ k ​$, and the discrete logarithm $ \log_ba ​$ is an integer $ k ​$ such that $ b^k=a ​$. Algorithms in public-key cryptography base their security on the assumption that the discrete logarithm problem over carefully chosen cyclic finite groups and cyclic subgroups of elliptic curves over finite fields has no efficient solution. ([<a href="https://en.wikipedia.org/wiki/Discrete_logarithm" title="Wikipedia: Discrete logarithm">5</a>], [<a href="http://www.semper.org/sirene/publ/SaSt_01.dh-et-al.long.pdf" title="Assumptions Related to Discrete Logarithms: 
Why Subtleties Make a Real Difference, 
Sadeghi A et al.">16</a>])</li>
</ul>
<ul>
<li><u><i>ElGamal Commitment/Encryption</i></u>:<a name="egc"> </a>An ElGamal commitment is a Pedersen Commitment<sup><a href="#pc" title="A Pedersen commitments is a system 
for making blinded non-interactive 
commitments to a value ...">def</a></sup> with an additional commitment $ g^r $ to the randomness used. The ElGamal encryption scheme is based on the Decisional Diffe-Hellman (DDH) assumption and the difficulty of the DLP for finite fields. The DDH assumption states that it is infeasible for a Probabilistic Polynomial-time (PPT) adversary to solve the DDH problem. (<i><strong>Note:</strong> The ElGamal encryption scheme should not be confused with the ElGamal signature scheme.</i>) ([<a href="http://web.stanford.edu/%7Ebuenz/pubs/bulletproofs.pdf" title="Bulletproofs: Short Proofs for Confidential Transactions 
and More, Blockchain Protocol Analysis and Security 
Engineering 2018, 
Bünz B. et al">1</a>], [<a href="http://www.e-ijaet.org/media/58I6-IJAET0612695.pdf" title="Intensified ElGamal Cryptosystem (IEC), Sharma P. et al.
International Journal of Advances in Engineering &amp; Technology,
Jan 2012">17</a>], [<a href="https://drive.google.com/file/d/16XGAByoXse5NQl57v_GldJwzmvaQlS94/view" title="On the Security of ElGamal Based Encryption,
Tsiounis Y. et al.">18</a>], [<a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption" title="Wikipedia: Decisional Diffie–Hellman assumption">19</a>])</li>
</ul>
<ul>
<li><u><i>Fiat–Shamir Heuristic/Transformation</i></u>:<a name="fsh"> </a>The Fiat–Shamir heuristic is a technique in cryptography to convert an interactive public-coin protocol (Sigma protocol) between a <em>prover</em> and a <em>verifier</em> into a one-message (non-interactive) protocol using a cryptographic hash function. ([<a href="https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf" title="How to Prove Yourself: Practical Solutions to 
Identification and Signature Problems, 
Fiat A. et al.">6</a>], [<a href="https://link.springer.com/content/pdf/10.1007%2F978-3-642-34961-4_38.pdf" title="How not to Prove Yourself: Pitfalls of the 
Fiat-Shamir Heuristic and Applications to Helios, 
Bernhard D. et al.">7</a>])
<ul>
<li>
<p>The <em>prover</em> will use a <code>Prove()</code> algorithm to calculate a commitment $ A $ with a statement $ Y $ that is shared with the <em>verifier</em> and a secret witness value $ w $ as inputs. The commitment $ A $ is then hashed to obtain the challenge $ c $, which is further processed with the <code>Prove()</code> algorithm to calculate the response $ f $. The single message sent to the <em>verifier</em> then contains the challenge $ c $ and response $ f $.</p>
</li>
<li>
<p>The <em>verifier</em> is then able to compute the commitment $ A $ from the shared statement $ Y $, challenge $ c $ and response $ f $. The <em>verifier</em> will then use a <code>Verify()</code> algorithm to verify the combination of shared statement $ Y $, commitment $ A $, challenge $ c $ and response $ f $.</p>
</li>
<li>
<p>A weak Fiat–Shamir transformation can be turned into a strong Fiat–Shamir transformation if the hashing function is applied to the commitment $ A $ and shared statement $ Y $ to obtain the challenge $ c $ as opposed to only the commitment $ A $.</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><u><em>Hadamard Product</em></u>:<a name="hdmp"> </a>In mathematics, the Hadamard product is a binary operation that takes two matrices $ \mathbf {A} , \mathbf {B} $ of the same dimensions, and produces another matrix of the same dimensions where each element $ i,j $ is the product of elements $ i,j $ of the original two matrices. The Hadamard product $ \mathbf {A} \circ \mathbf {B} $ is different from normal matrix multiplication most notably because it is also commutative $ [ \mathbf {A} \circ \mathbf {B} = \mathbf {B} \circ \mathbf {A} ] $ along with being associative $ [ \mathbf {A} \circ ( \mathbf {B} \circ \mathbf {C} ) = ( \mathbf {A} \circ \mathbf {B} ) \circ \mathbf {C} ] $ and distributive over addition $ [ \mathbf {A} \circ ( \mathbf {B} + \mathbf {C} ) = \mathbf {A} \circ \mathbf {B} + \mathbf {A} \circ \mathbf {C} ] $. ([<a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)" title="Wikipedia: Hadamard product (matrices)">21</a>])</li>
</ul>
<p>$$
\mathbf {A} \circ \mathbf {B} = \mathbf {C} = (a_{11} \cdot b_{11} \mspace{3mu} , \mspace{3mu} . . . \mspace{3mu} , \mspace{3mu} a_{1m} \cdot b_{1m} \mspace{6mu} ; \mspace{6mu} . . . \mspace{6mu} ; \mspace{6mu} a_{n1} \cdot b_{n1} \mspace{3mu} , \mspace{3mu} . . . \mspace{3mu} , \mspace{3mu} a_{nm} \cdot b_{nm} )
$$</p>
<ul>
<li><u><i>Zero-knowledge Proof/Protocol</i></u>:<a name="zk"> </a>In cryptography, a zero-knowledge proof/protocol is a method by which one party (the prover) can convince another party (the verifier) that a statement $ Y $ is true, without conveying any information apart from the fact that the prover knows the value of $ Y $. The proof system must be complete, sound and zero-knowledge. ([<a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof" title="Wikipedia - Zero-knowledge Proof">4</a>], [<a href="https://zkproof.org/documents.html" title="Zero Knowledge Proof Standardization - 
An Open Industry/Academic Initiative">9</a>])
<ul>
<li>
<p>Complete: If the statement is true and both prover and verifier follow the protocol; the verifier will accept.</p>
</li>
<li>
<p>Sound: If the statement is false, and the verifier follows the protocol; the verifier will not be convinced.</p>
</li>
<li>
<p>Zero-knowledge: If the statement is true and the prover follows the protocol, the verifier will not learn any confidential information from the interaction with the prover apart from the fact that the statement is true.</p>
</li>
</ul>
</li>
</ul>
<a class="header" href="#contributors" id="contributors"><h2>Contributors</h2></a>
<ul>
<li><a href="https://github.com/hansieodendaal">https://github.com/hansieodendaal</a></li>
<li><a href="https://github.com/neonknight64">https://github.com/neonknight64</a></li>
<li><a href="https://github.com/CjS77">https://github.com/CjS77</a></li>
<li><a href="https://github.com/philipr-za">https://github.com/philipr-za</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../cryptography/bulletproofs-and-mimblewimble/MainReport.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../consensus-mechanisms/consensus-mechanisms.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../../cryptography/bulletproofs-and-mimblewimble/MainReport.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../../consensus-mechanisms/consensus-mechanisms.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Initialize mermaid -->
        <script src="../../theme/js/mermaid.min.js" type="text/javascript" charset="utf-8"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
